import{_ as e,c as o,o as t,d as r}from"./app.ced819ec.js";const g='{"title":"Keys","description":"","frontmatter":{},"headers":[],"relativePath":"guide/appendix/keys.md","lastUpdated":1649230251000}',a={},s=r(`<h1 id="keys" tabindex="-1">Keys <a class="header-anchor" href="#keys" aria-hidden="true">#</a></h1><p>Now it&#39;s a good practice to worry about Public key cryptography, so we&#39;ll give you a primer. Firstly, public and private keys come in pairs. For a given private key it&#39;s easy to figure out the corresponding public key, <strong>but the opposite is not true</strong>. The fact that it&#39;s practically impossible to figure out what the <strong>private key</strong> corresponding to a given <strong>public key</strong> is why they&#39;re called <em>public</em> and <em>private</em>: <strong>one is safe to share without compromising on the security of the entire exchange</strong>. <strong>With a private key, you can encrypt information, in a way, such that only the people who have your public key can read it. You cannot encrypt anything with a public key</strong>. When we say signed we really mean <em>attached <strong>a known piece of data encrypted with the private key</strong>.</em> When something is <em>signed</em>, everyone can read it, and <strong>everyone with your public key can verify that the person who wrote that message used your private key</strong>. As a result, if you&#39;re deploying your own network, <strong>you really should change the keys in all three configuration files.</strong> To get new key-pairs, use the <code>iroha_crypto_cli</code> program,</p><div class="language-bash"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">cargo build -p iroha_crypto_cli</span></span>
<span class="line"><span style="color:#24292F;">./target/debug/iroha_crypto_cli</span></span>
<span class="line"></span></code></pre></div><p>Which will print a fresh pair of keys. If you want to set up your own network, you should change the keys for all your peers: in <code>peer/config.json</code> change <code>PUBLIC_KEY</code> and <code>PRIVATE_KEY</code>, to the fresh pair. When you&#39;ve done that, you should add the keys to the <code>TRUSTED_PEERS</code> array in the same configuration file. <strong>EXAMPLE:</strong> in the minimum viable BFT network, you have four peers, so that means that you need to create <em>four</em> different peer configuration files (<code>config.json</code>). Each peer should have its own <code>PUBLIC_KEY</code> and <code>PRIVATE_KEY</code> and all four public keys should be added to the <code>TRUSTED_PEERS</code> array (<em>yes including the peer that you&#39;re configuring</em>), and the same <code>TRUSTED_PEERS</code> array must be copied across all four configuration files. Next, you must make sure that the peers agree on the <code>GENESIS_ACCOUNT</code> key pairs.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Don&#39;t worry about the fact that the genesis account&#39;s private key is known to all peers, the genesis account loses all privileges after the first block gets committed.</p></div><p>Finally, while the first client <em>could</em> use the genesis account to register new users, it&#39;s not a great idea for private networks. You should, instead, register a non-genesis account (for example *alice@*wonderland) and <code>unregister</code> the genesis account.</p><div class="warning custom-block"><p class="custom-block-title">NB</p><p><code>iroha_client_cli</code> currently doesn&#39;t support unregister instructions, if you plan on creating a private blockchain, you should consider writing your own client based off of the <code>client</code> Rust crate, or any of the provided client libraries.</p></div><p>Here are the links to the <a href="https://github.com/hyperledger/iroha-python" target="_blank" rel="noopener noreferrer">iroha-python</a>, <a href="https://github.com/hyperledger/iroha-ios" target="_blank" rel="noopener noreferrer">iroha-iOS</a>, <a href="https://github.com/hyperledger/iroha-java" target="_blank" rel="noopener noreferrer">iroha-java</a> and <a href="https://github.com/hyperledger/iroha-javascript/tree/iroha2" target="_blank" rel="noopener noreferrer">iroha-javascript</a> libraries.</p><p>Finally, let&#39;s talk about how keys are used in the client. Every transaction is signed on behalf of some user, thus every operation requires a key. That doesn&#39;t mean that you need to explicitly provide a key every time. For example, you need to have a user to register a user (<em>just like you need scissors to open a bag with new scissors</em>). But in order to register a user, you must also provide a new public key, so that the network can verify that it&#39;s that trustworthy *mad_hatter@*wonderland, and not some impostor (<em>possibly sent by the red_queen),</em> so there are cases where you need to provide a key explicitly.</p><p>Each time <code>iroha_client_cli</code> asks you to provide a <code>--key</code> argument, it&#39;s probably a good idea to generate a new key-pair.</p>`,10),i=[s];function n(c,h,l,p,d,u){return t(),o("div",null,i)}var f=e(a,[["render",n]]);export{g as __pageData,f as default};
