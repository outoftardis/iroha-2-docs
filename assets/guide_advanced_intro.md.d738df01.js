import{_ as e,c as s,o as a,d as o}from"./app.ced819ec.js";const m='{"title":"Advanced Topics","description":"","frontmatter":{},"headers":[{"level":2,"title":"Iroha Special Instructions","slug":"iroha-special-instructions"},{"level":3,"title":"(Un)Register","slug":"un-register"},{"level":3,"title":"Mint/Burn","slug":"mint-burn"},{"level":3,"title":"Grant/Revoke","slug":"grant-revoke"},{"level":3,"title":"SetKeyValue/RemoveKeyValue","slug":"setkeyvalue-removekeyvalue"},{"level":3,"title":"Query","slug":"query"},{"level":3,"title":"Expressions, Conditionals, Logic","slug":"expressions-conditionals-logic"},{"level":2,"title":"WASM","slug":"wasm"},{"level":3,"title":"Simple Rust Smart Contract","slug":"simple-rust-smart-contract"},{"level":3,"title":"Advanced Smart Contracts: Optimising for Size","slug":"advanced-smart-contracts-optimising-for-size"},{"level":2,"title":"Triggers","slug":"triggers"}],"relativePath":"guide/advanced/intro.md","lastUpdated":1649230251000}',t={},n=o(`<h1 id="advanced-topics" tabindex="-1">Advanced Topics <a class="header-anchor" href="#advanced-topics" aria-hidden="true">#</a></h1><p>This is the part of the tutorial, where we say &quot;you&#39;re not a newbie anymore&quot; and hit you hard with the features that make Iroha truly special. Here we will cover in some breadth the <em>Iroha special instructions</em>, Web-assembly, and how both are used in creating what&#39;s know as a <em>smart contract</em>.</p><p>The basic premise is; if the blockchain is the computer, then <code>iroha_client_cli</code> or any of the client libraries for that matter, are the keyboard, the blockchain is the hard drive, and the Iroha peer software is the processor. Like a processor, Iroha accepts portable instructions which modify what&#39;s written to the blockchain, allow certain users to use the network, and lock out others.</p><p>As such any operation that is run on-chain is written in terms of Iroha Special Instructions (ISI), and there is no other way of modifying the world state that would pass consensus. To understand why, we&#39;ll need to make a short detour into how Iroha is implemented under the hood.</p><p>Each interaction with the blockchain is done via a <em>transaction</em>. It&#39;s a collection of instructions, either glued together in sequence or called from a WASM blob (more on that later), that can register an account, remove an account, add X amount of Y currency etc. There are also queries, which return some values that you are allowed to access, which are also instructions. Each time you send a transaction to Iroha, it gets put into a queue, and when the time comes, the queue is emptied, and the consensus process begins. This process is a bit of mundane with a bit of black magic<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. The mundane, is that a special set of peers needs to take the transaction queue, and reproduce the same world state. If the world state cannot be reproduced for some reason or another, none of the transactions get committed to a block and consensus tries again. The reasoning behind this algorithm is simple: if someone had some evil peers and connected them to the existing network, if they tried to fake data, some good\u2122 peers would not get the same (evil\u2122) world state. If that&#39;s the case, the evil\u2122 peers would not be allowed to participate in consensus, and you would eventually produce a block using only good\u2122 peers. So if any changes to the world state are made without using ISI, they would not pass consensus and never get committed to a block.</p><h2 id="iroha-special-instructions" tabindex="-1">Iroha Special Instructions <a class="header-anchor" href="#iroha-special-instructions" aria-hidden="true">#</a></h2><p>So what kinds of ISI do we have? If you&#39;ve read the tutorial on Rust or Python, you&#39;ve already seen a couple of instructions: <code>Register&lt;Account&gt;</code> and <code>Mint&lt;Quantity&gt;</code>. For the exhaustive list of Instructions you should probably consult our source code, however, here are some important classes.</p><h3 id="un-register" tabindex="-1">(Un)Register <a class="header-anchor" href="#un-register" aria-hidden="true">#</a></h3><p>Instructions used to give an ID to a new entity on the blockchain. Everything that can be registered is <code>Identifiable</code>, but not everything that&#39;s <code>Identifiable</code> can be registered. As a rule, everything that can be registered, can also be un-registered, but that is not a hard and fast rule.</p><p>You can register a new account, a new asset definition a peer and a trigger (more on them later). Registering a peer is currently the only way of adding peers that were not part of the original <code>TRUSTED_PEERS</code> array to the network.</p><p>Registering an account is different. Iroha can be compiled in two modes: <em>public</em> and <em>private</em>. If it&#39;s compiled with <em>private</em> permissions, to register an account, you need an account. This is the default. If you want your users to be able to register without access to a pre-existing account, you need to compile Iroha in the <em>public</em> mode.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>As of writing, the set of public blockchain permissions is incomplete, and as such Iroha source code needs to be modified to run it in the <em>public</em> mode.</p></div><h3 id="mint-burn" tabindex="-1">Mint/Burn <a class="header-anchor" href="#mint-burn" aria-hidden="true">#</a></h3><p>Can refer to assets, trigger uses (if the trigger has a limited number of repetitions), as well as temporary permission tokens. Some assets can be declared as non-mintable, meaning that any attempt to mint them post-registration will result in an error.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>This will be changed in RC3.</p></div><p>Assets and permissions tokens need to be minted to a specific account, usually the one that registered the asset in the first place. All assets are assumed to be non-negative as well, so you can never have <code>-1.0</code> of <code>time</code> or <code>Burn</code> a negative amount and get a <code>Mint</code>.</p><h3 id="grant-revoke" tabindex="-1">Grant/Revoke <a class="header-anchor" href="#grant-revoke" aria-hidden="true">#</a></h3><p>These are used specifically for permissions. When minting a permission token a user is granted <code>X</code> amount of permissions to do <code>Y</code> which will expire once all <code>X</code> operations were performed. By contrast, a <code>Grant</code> operation can be used to grant either a single permission, or a group of permissions (or a &quot;role&quot;), to a user permanently. As such these instructions should be used carefully.</p><h3 id="setkeyvalue-removekeyvalue" tabindex="-1">SetKeyValue/RemoveKeyValue <a class="header-anchor" href="#setkeyvalue-removekeyvalue" aria-hidden="true">#</a></h3><p>These instructions are used with the key/value store asset type. This use case has not received much attention so far, because storing data in the blockchain is rather advanced topic that we shall cover separately.</p><h3 id="query" tabindex="-1">Query <a class="header-anchor" href="#query" aria-hidden="true">#</a></h3><p>These are all the queries that can be made from the client side. This is not necessarily the only kind of information that is available on the network, but it&#39;s the only kind of information that is guaranteed to be accessible on all networks. Telemetry data is optional to the specific deployment of Iroha. Access to your account balance is required function.</p><h3 id="expressions-conditionals-logic" tabindex="-1">Expressions, Conditionals, Logic <a class="header-anchor" href="#expressions-conditionals-logic" aria-hidden="true">#</a></h3><p>All ISI operate on expressions. Each expression has an <code>EvaluatesTo</code> which is used in instruction execution. While you could specify the account name directly, you could also specify the account ID via some mathematical or string operation. You can check if an account is registered on the blockchain too.</p><p>Using expressions which implement <code>EvaluatesTo&lt;bool&gt;</code>, you can set up conditional logic and execute more sophisticated operations on-chain. For example, you can submit a <code>Mint</code> instruction only if a specific account is registered. Recall that you can combine this with queries, and as such can program the blockchain to do some amazing stuff. This stuff is what we refer to as <em>smart contracts</em>, and is the main defining feature of advanced usage of blockchain technology.</p><h2 id="wasm" tabindex="-1">WASM <a class="header-anchor" href="#wasm" aria-hidden="true">#</a></h2><p>While we had initially assumed that all operations within Iroha will be handled with instructions and conditionals, there are a few problems with this approach.</p><pre><code>1. The ISI syntax is verbose and ugly.
2. The ISI syntax is not familiar for most programmers.
3. While ISI smart contracts are compact (usually a few bytes), they need to be hand-optimised.
</code></pre><p>In the long run, all of these problems are taken care of by using a <strong>domain-specific language</strong>, which gets optimised and compiled into a sequence of instructions that executes fast, and takes very little space in the blocks, but is also easy to understand. Something that looks like your traditional <code>if</code> statements and <code>for</code> loops.</p><p>However, in the interim, we have decided to use another portable binary standard called <strong>Web assembly</strong> or <strong>WASM</strong>. The main advantage of this format is that you can use any language you like (as long as it links statically against our helper library), and produce a 32-bit portable executable. The compilers take care of the optimisation, and you don&#39;t have to learn a new language (ahem\u2026 solidity\u2026 ahem), just to operate on the blockchain.</p><p>You&#39;d still need to use ISI from inside your WASM binary to do anything on-chain, but you can do other things, and write e.g. Rust instead of composing Generic <code>structs</code> inside a macro to get conditional logic. Moreover, as long as you fit within the limits of WASM runtime, and the provided libraries, you can do anything (and everything) you want.</p><p>The drawback is that this process is a tad more involved than just writing the ISI using the client libraries.</p><h3 id="simple-rust-smart-contract" tabindex="-1">Simple Rust Smart Contract <a class="header-anchor" href="#simple-rust-smart-contract" aria-hidden="true">#</a></h3><p>WASM projects, just like any other binary in Rust need to be separate crates. Don&#39;t worry, it doesn&#39;t have to be big.</p><p>To get started you might want to use</p><div class="language-bash"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">cargo new --lib</span></span>
<span class="line"></span></code></pre></div><p>to create a new project. Yes, we need the <code>lib</code> type, more on that later.</p><p>The <code>Cargo.toml</code> of the project should look something like this:</p><div class="language-toml"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">[</span><span style="color:#953800;">package</span><span style="color:#24292F;">]</span></span>
<span class="line"><span style="color:#24292F;">name  = </span><span style="color:#0A3069;">&quot;smartcontract&quot;</span></span>
<span class="line"><span style="color:#24292F;">version = </span><span style="color:#0A3069;">&quot;0.1.0&quot;</span></span>
<span class="line"><span style="color:#24292F;">edition = </span><span style="color:#0A3069;">&quot;2021&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">[</span><span style="color:#953800;">lib</span><span style="color:#24292F;">]</span></span>
<span class="line"><span style="color:#24292F;">crate-type = [</span><span style="color:#0A3069;">&#39;cdylib&#39;</span><span style="color:#24292F;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">[</span><span style="color:#953800;">dependencies</span><span style="color:#24292F;">]</span></span>
<span class="line"><span style="color:#24292F;">iroha_wasm = { git = </span><span style="color:#0A3069;">&quot;https://github.com/hyperledger/iroha/&quot;</span><span style="color:#24292F;">, branch = </span><span style="color:#0A3069;">&quot;iroha2&quot;</span><span style="color:#24292F;"> }</span></span>
<span class="line"></span></code></pre></div><p>Note that the crate type is <code>cdylib</code>. Most Rust code is linked in a non-portable architecture and OS-specific static manner, but WASM is a portable format. Since C ABI is the <em>lingua franca</em> of the programming world and there is no other stable Rust ABI (yet), Iroha relies on the C-linkage to generate WASM bindings. Thankfully, you don&#39;t need to worry about foreign function interface (FFI)-related problems like <code>unsafe</code>, <code>repr(C)</code>, padding, alignment etc., <code>iroha_wasm</code> takes care of all that for you.</p><p><code>iroha_wasm</code> is the crate that contains all of the bindings, macros and trait implementations that you&#39;d need to write the program, most notably the <code>iroha_wasm</code> attribute macro. The crate also exposes our <code>data_model</code> which contains all of the basic ISI and types. <code>parity-scale-codec</code> is (as of today) the chosen serialisation format with a strong possibility of getting replaced with a different (custom) serialisation format in the near future, as it seems to dominate the binary size<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p><p>Now that we have the preliminaries nailed down, we get to write some code for our smart contract. In the <code>src/lib.rs</code> you should write the following:</p><div class="language-rust"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">#</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">[no_std]</span></span>
<span class="line"><span style="color:#24292F;">#</span><span style="color:#CF222E;">!</span><span style="color:#24292F;">[no_main]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">extern</span><span style="color:#24292F;"> </span><span style="color:#CF222E;">crate</span><span style="color:#24292F;"> alloc;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">use</span><span style="color:#24292F;"> </span><span style="color:#953800;">alloc</span><span style="color:#CF222E;">::</span><span style="color:#953800;">vec</span><span style="color:#CF222E;">::</span><span style="color:#953800;">Vec</span><span style="color:#24292F;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CF222E;">use</span><span style="color:#24292F;"> </span><span style="color:#953800;">iroha_wasm</span><span style="color:#CF222E;">::</span><span style="color:#953800;">data_model</span><span style="color:#CF222E;">::</span><span style="color:#953800;">prelude</span><span style="color:#CF222E;">::*</span><span style="color:#24292F;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">#[iroha_wasm</span><span style="color:#CF222E;">::</span><span style="color:#24292F;">iroha_wasm]</span></span>
<span class="line"><span style="color:#CF222E;">fn</span><span style="color:#24292F;"> </span><span style="color:#8250DF;">smartcontract_entry_point</span><span style="color:#24292F;">(_account_id</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">AccountId</span><span style="color:#24292F;">) {</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> query </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#953800;">QueryBox</span><span style="color:#CF222E;">::</span><span style="color:#8250DF;">FindAllDomains</span><span style="color:#24292F;">(</span><span style="color:#953800;">FindAllDomains</span><span style="color:#24292F;"> {});</span></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> domains</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">Vec</span><span style="color:#24292F;">&lt;</span><span style="color:#953800;">Domain</span><span style="color:#24292F;">&gt; </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> query</span><span style="color:#CF222E;">.</span><span style="color:#8250DF;">execute</span><span style="color:#24292F;">()</span><span style="color:#CF222E;">.</span><span style="color:#8250DF;">try_into</span><span style="color:#24292F;">()</span><span style="color:#CF222E;">.</span><span style="color:#8250DF;">unwrap</span><span style="color:#24292F;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">    </span><span style="color:#CF222E;">for</span><span style="color:#24292F;"> domain </span><span style="color:#CF222E;">in</span><span style="color:#24292F;"> domains {</span></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#CF222E;">let</span><span style="color:#24292F;"> new_account_id </span><span style="color:#CF222E;">=</span><span style="color:#24292F;"> </span><span style="color:#953800;">AccountId</span><span style="color:#24292F;"> {</span></span>
<span class="line"><span style="color:#24292F;">            name</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> </span><span style="color:#953800;">Name</span><span style="color:#CF222E;">::</span><span style="color:#8250DF;">new</span><span style="color:#24292F;">(</span><span style="color:#0A3069;">&quot;mad_hatter&quot;</span><span style="color:#24292F;">)</span><span style="color:#CF222E;">.</span><span style="color:#8250DF;">unwrap</span><span style="color:#24292F;">(),</span></span>
<span class="line"><span style="color:#24292F;">            domain_id</span><span style="color:#CF222E;">:</span><span style="color:#24292F;"> domain</span><span style="color:#CF222E;">.</span><span style="color:#24292F;">id,</span></span>
<span class="line"><span style="color:#24292F;">        };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292F;">        </span><span style="color:#953800;">Instruction</span><span style="color:#CF222E;">::</span><span style="color:#8250DF;">Register</span><span style="color:#24292F;">(</span><span style="color:#953800;">RegisterBox</span><span style="color:#CF222E;">::</span><span style="color:#8250DF;">new</span><span style="color:#24292F;">(</span><span style="color:#953800;">NewAccount</span><span style="color:#CF222E;">::</span><span style="color:#8250DF;">new</span><span style="color:#24292F;">(new_account_id)))</span><span style="color:#CF222E;">.</span><span style="color:#8250DF;">execute</span><span style="color:#24292F;">();</span></span>
<span class="line"><span style="color:#24292F;">    }</span></span>
<span class="line"><span style="color:#24292F;">}</span></span>
<span class="line"></span></code></pre></div><p><code>cargo run --release</code> will submit the instruction and run it for you (be sure to have a peer up).</p><p>What this smart contract does is query all of the currently existing domains, put the results into a <code>std::vec::Vec</code>, which in this case has to be imported from <code>alloc</code>, as we use <code>no_std</code> (more on that later), which is then used to add the user named <code>mad_hatter</code> to all of the existing domains.</p><p>Building the same logic out of <code>Expression</code> and <code>If</code> and <code>Sequence</code> would be significantly harder. Moreover, the actual low-level instructions that would run are very likely not going to be as well-optimised as what the compiler produces.</p><h3 id="advanced-smart-contracts-optimising-for-size" tabindex="-1">Advanced Smart Contracts: Optimising for Size <a class="header-anchor" href="#advanced-smart-contracts-optimising-for-size" aria-hidden="true">#</a></h3><p>WASM smart contracts can get big. So big, in fact, that we might not let you store them in the blockchain. So how do you reduce the size? The most important modifications are done in <code>Cargo.toml</code>:</p><div class="language-toml"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"></span>
<span class="line"><span style="color:#24292F;">[</span><span style="color:#953800;">profile</span><span style="color:#24292F;">.</span><span style="color:#953800;">release</span><span style="color:#24292F;">]</span></span>
<span class="line"><span style="color:#24292F;">strip = </span><span style="color:#0A3069;">&quot;debuginfo&quot;</span><span style="color:#24292F;"> </span><span style="color:#6E7781;"># Remove debugging info from the binary</span></span>
<span class="line"><span style="color:#24292F;">panic = </span><span style="color:#0A3069;">&quot;abort&quot;</span><span style="color:#24292F;">     </span><span style="color:#6E7781;"># Panics are transcribed to Traps when compiling for wasm anyways</span></span>
<span class="line"><span style="color:#24292F;">lto = </span><span style="color:#0550AE;">true</span><span style="color:#24292F;">          </span><span style="color:#6E7781;"># Link-time-optimisation produces notable decrease in binary size</span></span>
<span class="line"><span style="color:#24292F;">opt-level = </span><span style="color:#0A3069;">&quot;z&quot;</span><span style="color:#24292F;">     </span><span style="color:#6E7781;"># Optimise for size vs speed with &quot;s&quot;/&quot;z&quot;(removes vectorization)</span></span>
<span class="line"><span style="color:#24292F;">codegen-units = </span><span style="color:#0550AE;">1</span><span style="color:#24292F;">   </span><span style="color:#6E7781;"># Further reduces binary size but increases compilation time</span></span>
<span class="line"></span></code></pre></div><p>Rust stores a lot of debug information (even when compiled in <code>release</code> mode), which is (as the name suggests) used for debugging a panic in your Rust application. As you would expect, this information increases the size of the compiled WASM significantly. Normally, this would be a worthwhile trade-off, but not in our case. Firstly, since the WASM is stored on-chain, it will be permanently recorded in some block and take space on every full node of an Iroha network (which by the way, stores a lot of its information in RAM), so storage space for WASM is at a premium. Secondly, once the WASM smart contract is stored on-chain, the debug information is no longer accessible. Indeed, you shouldn&#39;t debug on a peer. Instead, you should replicate the conditions that caused the panic locally and debug on your personal machine.</p><p>Another step that we&#39;ve already taken involves working under a <code>no_std</code> environment. All of our size-related woes stem from Rust being predominantly statically linked. As such, breaking the standard library into more manageable crates, like using <code>alloc::vec</code> instead of <code>std::vec</code> can help us reduce the size and compilation time<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>.</p><p>Next, you&#39;re advised to re-compile <code>libcore</code> and any other standard library crate (e.g. <code>alloc</code>) to exclude the leftover panic-related code that comes with prebuilt the <code>core</code> library<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>:</p><div class="language-bash"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">cargo +nightly build -Z build-std -Z build-std-features=panic_immediate_abort --target wasm32-unknown-unknown</span></span>
<span class="line"></span></code></pre></div><p>Unfortunately, this is an unstable feature. In other words, the developers of the Rust programming language can decide to change how this works, or remove this option entirely.</p><p>Finally, you can use an automated tool to optimise the size of the WASM using <a href="https://github.com/WebAssembly/binaryen" target="_blank" rel="noopener noreferrer"><code>wasm-opt</code></a>, or use <a href="https://rustwasm.github.io/twiggy/" target="_blank" rel="noopener noreferrer"><code>twiggy</code></a> to guide your manual optimisation efforts. Using <code>wasm-opt</code> is highly advised because it will often significantly reduce your binary size, e.g.:</p><div class="language-bash"><pre class="shiki shiki-light" style="background-color:#ffffff;"><code><span class="line"><span style="color:#24292F;">wasm-opt -Os -o output.wasm input.wasm</span></span>
<span class="line"></span></code></pre></div><p>At some, point, unfortunately, the smallest size of your WASM blob is going to be determined by the libraries that you need to use. Using all of the above steps on the provided smart contract, can reduce it down to a manageable (for the blockchain) size. Stay tuned for RC3 for further optimisations of binary size.</p><h2 id="triggers" tabindex="-1">Triggers <a class="header-anchor" href="#triggers" aria-hidden="true">#</a></h2><p>The basic premise is that certain things can emit events: it could be a change of the state of some entity, e.g. an account, and/or a domain (you can&#39;t modify an account without changing the domain that it belongs to, but you can change the domain without touching any of its accounts), but it could also be the block being committed, some point in time being crossed, or even a direct signal emitted by executing a special ISI. All of these are events that triggers can be attached to.</p><p>A trigger is a fairly basic entity that can be registered. Just like with Accounts, you submit a <code>RegisterBox::Trigger</code>, which contains the necessary information. This information is a single account ID, which should ideally be a brand new account that you register in the same transaction (but for now it doesn&#39;t matter); an executable, which itself is either a <code>Vec&lt;Instruction&gt;</code> or a WASM blob; and an <code>EventFilter</code>, something which combs through (at this point all) events and returns <code>true</code> when it finds an event that you like to start the execution.</p><p>The documentation on the <code>EventFilter</code> types is under construction, as we are likely to make major changes to that particular architecture. For now, suffice it to say that you can look at the source code in <code>iroha_data_model</code> and see a few particularly interesting applications.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>For prospective wizards, the whitepaper is a good start (TODO: link). <a href="#fnref1" class="footnote-backref">\u21A9\uFE0E</a></p></li><li id="fn2" class="footnote-item"><p>Size is an important metric. We shall cover size-optimisation strategies as we go. <a href="#fnref2" class="footnote-backref">\u21A9\uFE0E</a></p></li><li id="fn3" class="footnote-item"><p>It should be noted, that excluding the standard library is necessary for compiling to the wasm32 target, and is thus mandatory. <a href="#fnref3" class="footnote-backref">\u21A9\uFE0E</a></p></li><li id="fn4" class="footnote-item"><p><code>wasm-opt</code> can also be used to remove the debug sections. <a href="#fnref4" class="footnote-backref">\u21A9\uFE0E</a></p></li></ol></section>`,63),i=[n];function r(l,c,p,d,h,u){return a(),s("div",null,i)}var f=e(t,[["render",r]]);export{m as __pageData,f as default};
